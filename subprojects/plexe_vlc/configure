#!/usr/bin/env python3

#
# Copyright (C) 2013-2020 Christoph Sommer <sommer@ccs-labs.org>
#
# Documentation for these modules is at http://veins.car2x.org/
#
# SPDX-License-Identifier: GPL-2.0-or-later
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

"""
Creates Makefile(s) for building this project.
"""
from os import mkdir
from os.path import join, relpath, isdir
import sys
import subprocess
from optparse import OptionParser


class Library:
    def __init__(self, name, library, default_path, versions, source_folder,
                 lib_folder, images_folder, version_script, defs=[],
                 run_version_script=True, ned_folder=None):
        self.name = name
        self.library = library
        self.default_path = default_path
        self.versions = versions
        self.src_dir = source_folder
        self.lib_dir = lib_folder
        self.images_dir = images_folder
        self.version_script = version_script
        self.defs = defs
        self.run_version_script = run_version_script
        if ned_folder is None:
            self.ned_dir = self.src_dir
        else:
            self.ned_dir = ned_folder

    def run_version(self, path):
        fname = join(path, self.version_script)
        return subprocess.check_output(["env", fname]).strip().decode()

    def read_version(self, path):
        fname = join(path, self.version_script)
        with open(fname, "r") as file:
            return file.read().rstrip()

    def add_to_parser(self, parser):
        help = "link with a version of {} installed in PATH [default %default]"
        help = help.format(self.name)
        parser.add_option("--with-{}".format(self.library), dest=self.library,
                          help=help, metavar="PATH", default=self.default_path)

    def print_unsupported_version(self, version):
        txt = "Unsupported {} Version. Expecting {}, found {}"
        txt = txt.format(self.name, " or ".join(self.versions), version)
        print(txt)

    def print_library_error(self, error):
        versions = " or ".join(self.versions)
        txt = "Could not determine {name} version (by running {script}): "\
              "{error}. Check the path to {name} (--with-{lib}=... option) "\
              "and the {name} version (should be version {versions})"
        txt = txt.format(name=self.name, script=self.version_script,
                         error=error, lib=self.library, versions=versions)
        print(txt)

    def check(self, options, flags, libs, neds, imgs):
        if hasattr(options, self.library):
            path = getattr(options, self.library)
            name = self.name
            try:
                print("Determining {} version.".format(name))
                if self.run_version_script:
                    version = self.run_version(path)
                else:
                    version = self.read_version(path)
                if version not in self.versions:
                    print("")
                    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                    self.print_unsupported_version(version)
                    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                    print("")
                else:
                    print("Found {} version {}. Okay.".format(name, version))

                    header_dirs = [
                        join(relpath(path, self.lib_dir), self.lib_dir)
                    ]
                    includes = ["-I" + s for s in header_dirs]
                    link = [
                        "-L" + join(relpath(path, self.lib_dir), self.lib_dir),
                        "-l{}$(D)".format(self.library)
                    ]
                    defs = self.defs
                    flags.extend(includes + link + defs)
                    libs.append(relpath(join(path, self.src_dir)))
                    neds.append(relpath(join(path, self.ned_dir)))
                    imgs.append(relpath(join(path, self.images_dir)))

            except subprocess.CalledProcessError as e:
                self.print_library_error(e)
                sys.exit(1)


class LibraryChecker:
    def __init__(self):
        self.parser = OptionParser()
        self.libs = []

    def add_lib(self, lib):
        lib.add_to_parser(self.parser)
        self.libs.append(lib)

    def check_libraries(self, flags, libs, neds, imgs):
        options, args = self.parser.parse_args()
        for lib in self.libs:
            lib.check(options, flags, libs, neds, imgs)


plexe = Library(name="Plexe", library="plexe", default_path="../../",
                versions=["3.0"], source_folder="src/plexe",
                lib_folder="src", images_folder="images",
                version_script="print-plexe-version")
veins = Library(name="Veins", library="veins", default_path="../../../veins",
                versions=["5.1"], source_folder="src/veins", lib_folder="src",
                images_folder="images", version_script="print-veins-version")
veins_vlc = Library(name="Veins VLC", library="veins-vlc",
                    default_path="../../../veins_vlc", versions=["1.0"],
                    source_folder="src/veins-vlc", lib_folder="src",
                    images_folder="images",
                    version_script="print-veins_vlc-version")

libraries = LibraryChecker()
libraries.add_lib(plexe)
libraries.add_lib(veins)
libraries.add_lib(veins_vlc)

# Start with default flags
makemake_flags = ["-f", "--deep", "--no-deep-includes", "--make-so", "-I", ".", "-o", "plexe_vlc", "-O", "out", "-p", "PLEXE_VLC"]
run_libs = [join("src", "plexe_vlc")]
run_neds = [join("src", "plexe_vlc")]
run_imgs = []

libraries.check_libraries(makemake_flags, run_libs, run_neds, run_imgs)

# Start creating files
if not isdir("out"):
    mkdir("out")

f = open(join("out", "config.py"), "w")
f.write("run_libs = %s\n" % repr(run_libs))
f.write("run_neds = %s\n" % repr(run_neds))
f.write("run_imgs = %s\n" % repr(run_imgs))
f.close()

subprocess.check_call(["env", "opp_makemake"] + makemake_flags, cwd="src")

print("Configure done. You can now run 'make'.")
